\documentclass[12pt]{article}
\usepackage{amsmath,amssymb,parskip,custom}
\usepackage[margin=1in]{geometry}
\begin{document}

\title{CS 240 --- Data Structures and Data Management}
\author{Kevin James}
\date{\vspace{-2ex}Spring 2014}
\maketitle\HRule

\section{Algorithms}
An {\bf algorithm} is a step-by-step process for carrying out a set of operations given an arbitrary problem instance. An algorithm {\bf solves} a problem if, for every instance of the problem, the algorithm finds a valid solution in finite time.

A {\bf program} is an implementation of an algorithm using a specified programming language.

For each problem we can have several algorithms and for each algorithm we can have several programs (implementations).

In practice, given a problem:
\begin{enumerate}
\item Design an algorithm.
\item Assess the correctness of that algorithm.
\item If the algorithm is acceptable, implement it. Otherwise, return to step 1.
\end{enumerate}

When determining the efficiency of algorithms, we tend to be primarily concerned with either the runtime or the memory requirements. In this course, we will focus mostly on the runtime.

To perform runtime analysis, we may simply implement the algorithm and use some method to determine the end-to-end time of the program. Unfortunately, this approach has many variables: test system, programming language, programmer skill, compiler choice, input selection, \dots. This, of course, makes manual implementation a bad approach.

An idealized implementation uses a {\bf Random Access Machine (RAM)} model. RAM systems have constant time access to memory locations and constant time primitive operations, thus the running time is determinable (as the number of memory operations plus the number of primitive operations).

We can also generally use {\bf order notation} to compare multiple algorithms. For the most part, we compare assuming $n$ is very large, since for small values of $n$ the runtime will be miniscule regardless of algorithm.

We denote the runtime of a function as $T(f(x))$, for example: $T(3 \times 4)$ may be equal to $0.8ns = 8\text{ops}$. The return value is the number of operations required in the worst-case scenario.

Example: given $T_A(n) = 1 000 000n + 2 000 000 000$ and $T_B(n) = 0.01n^2$, which is `better'? For $n < 100 000 000$, algorithm $B$ is better. Since we only care about large inputs, though, we say $A$ is better overall.

\begin{example}
Prove that $2010n^2 + 1388 = \mathbb{O}(n^3)$.
\end{example}

\begin{proof}
$\forall c > 0$, $2010 n^2 + 1388 \leq cn^3$\\
$n > 1388 \implies 2010n^2 + 1388 \leq 2011n^2 \leq cn^3$\\
$2011n^2 \leq cn^3 \iff 2011 \leq cn$\\
$n > \frac{2011}{c} = n_0$
\end{proof}

\begin{definition}
$f(n) = \mathbb{O}(g(n))$ if there exists a positive real number $c$ and an integer $n_0 > 0$ such that $\forall n \geq n_0$, $f(n) \leq cg(n)$.
\end{definition}

More concretely, we can say that $f(n) = \mathbb{O}(af(n))$ and $a^\prime f(n) = \mathbb{O}(f(n))$. It's also worth noting that order notation is transitive (e.g.\ $f(n) = \mathbb{O}(g(n))$ and $g(n) = \mathbb{O}(h(n))$ implies $f(n) = \mathbb{O}(h(n))$).

We use five different symbols to denote order notation:
\begin{itemize}
\item $o$ denotes a function \emph{always less} than a given order
\item $\mathbb{O}$ denotes a function \emph{less than or equal} to a given order
\item $\Theta$ denotes a function \emph{exactly equal} to a given order
\item $\Omega$ denotes a function \emph{greater than or equal} to a given order
\item $\omega$ denotes a function \emph{always greater} than a given order
\end{itemize}

\begin{example}
For the psuedo-function
\begin{verbatim}
function(n):
    sum = 0
    for i=1 to n:
        for j=i to n:
            sum = sum + (i-j)^2
            sum = sum^2
    return sum
\end{verbatim}
we find the order equation
\begin{align*}
&= \Theta(1) + \sum_{i=1}^n \sum_{j=i}^n \Theta(1) + \Theta(1)\\
&= \Theta(1) \sum_{i=1}^n \sum_{j=1}^n 1\\
&= \Theta(1) \sum_{i=1}^n (n-i+1)\\
&= \Theta(1) \bigg( \sum_{i=1}^n n - \sum_{i=1}^n i + \sum_{i=1}^n 1 \bigg)\\
&= \Theta(1) \bigl( n^2 + i^n + n \bigl)\\
&= \Theta(n^2) + \Theta(i^n) + \Theta(n)
\end{align*}
\end{example}

\begin{example}
For the psuedo-function
\begin{verbatim}
function(A,n):
    max = 0
    for i=1 to n:
        for j=i to n:
        sum = 0
        for k=1 to j:
        	sum = A[k]
        	if sum > max:
        		max = sum
    return max
\end{verbatim}
we find the order equation
\begin{align*}
&= \sum_{i=1}^n \sum_{j=i}^n \bigl( 1 + \sum_{k=i}^j c \bigl)\\
&= \sum_{i=1}^n \sum_{j=i}^n c(j-i+1)\\
&= \sum_{i=1}^n \sum_{j=1}^{n-i+1} j\\
&= \sum_{i=1}^n \Theta(n-i+1)\\
&= \sum_{i=1}^n \Theta(i)
\end{align*}
\end{example}

\begin{example}
For the psuedo-function
\begin{verbatim}
function(n):
    sum = 0
    for i=1 to n:
    	j = i
        while j >= 1:
        	sum = sum + i/j
        	j = j/2
    return sum
\end{verbatim}
we find the order equation
\begin{align*}
\sum_{i=1}^n \sum_{j=1}^{\log_2 i} c &= \sum_{i=1}^n (c \log_2 i)\\
&= c\bigl(\log 1 + \log 2 + \log 3 + \cdots + \log n\bigl)\\
\text{all }n\text{ of our terms are below }\log n &\hspace{40pt} \text{half of our }n\text{ terms are above }\frac{n}{2}\\
= \mathbb{O}(n\log n) &\hspace{40pt}= \Omega(\frac{n}{2}\log\frac{n}{2})\\
&\hspace{40pt}= \Omega(n\log n)\\
&= \Theta(n\log n)
\end{align*}
\end{example}

\section{Data Types}
\subsection{Dynamic Arrays}
Linked lists support $\mathbb{O}(1)$ insertion and deletion, $\mathbb{O}(n)$ accessing. Arrays are vice-versa.

{\bf Dynamic arrays} offer a compromise: $\mathbb{O}(1)$ for both, but can only insert or delete from the end of the list.

% BEGIN OTHER LECTURER
\subsection{Heaps}
Given a binary tree such that all levels are filled except for the lowest ({\bf heap structure property}) where all nodes have a lower value than that of their parent ({\bf heap ordering property}), we have the size of the heap $h$ given by $\log(n+1) - 1 \leq h \leq \log h$ or $h=\lfloor\log n\rfloor$.

Note that we do not implement tree-like data structures as such, but rather as arrays.

Heap functions have worst case running times bounded as follows
\begin{itemize}
\item Heap insertion: $\Theta(\log n)$
\item Heap deletion: $\Theta(\log n)$
\item Top-down heap creation: $\Theta(n\log n)$
\item Bottom-up heap creation: $O(n)$
\end{itemize}

\subsubsection{Heap Insert}
The item to-be-inserted must be placed in the only possible location to preserve integrity: i.e.\ the bottom level in the first available position. However, this may violate heap ordering procedure; we must perform bottom-up heap swaps until the ordering is satisfied.

To perform a bottom-up heap swap, we must
\begin{itemize}
\item compare node with parent
\item if the node is larger than the parent
\begin{itemize}
\item swap
\item recurse
\end{itemize}
\item else
\begin{itemize}
\item quit
\end{itemize}
\end{itemize}

These swaps can be performed in $\Theta(1)$ time and since the maximum number of swaps is equal to the height of the heap we have an overall time complexity of $\Theta(\log n)$. This worst case would occur when the item to-be-inserted is larger than anything else on the heap, since it would need to swap all the way to the top.

\subsubsection{Heap Delete}
The item to-be-deleted can simply be removed form our heap; however, we must replace this vacated position with the lowest item in our heap. This satisfies the structural integrity of the heap. Afterward, we must follow top-down heap swapping in order to satisfy ordering integrity.

To perform a top-down heap swap, we must
\begin{itemize}
\item compare node with children
\item if the node is smaller than at least one child
\begin{itemize}
\item swap with the largest child
\item recurse
\end{itemize}
\item else
\begin{itemize}
\item quit
\end{itemize}
\end{itemize}

Again, these swaps can be performed in $\Theta(1)$ time and we can perform no more than $\lfloor\log n\rfloor$ swaps. As such, we have worst case time complexity $\Theta(\log n)$ when the deleted item is at the top of the heap and the replacement item is the smallest in the heap.

\subsubsection{Heap Creation}
Given an array in no particular order, our goal is to adjust the ordering such that we have a valid heap.

The obvious approach is to call the heap insertion method once for each item in our input array. This is the {\bf top-down} approach to heap creation.

This can generally done in place, as we can treat the input array as a structurally valid but orderingly incorrect binary tree. As such, each insertion operation simply `ignores' values to its right. Since we are calling out $\Theta(\log n)$ insertion method $n$ times, we see that top-down heap creatoin has runtime complexity $\Theta(n\log n)$.

More formally, we see we have an upper bound such that the cost of the swaps is proportional to the depth of the node (i.e.\ which level it is on) and the number of nodes to process. This depth is given by $O(\log n)$ and the number of nodes by $n$, so we have $O(n\log n)$ as our upper bound. Our lower bound is given as such: the worst case occurs when the input array is sorted in ascending order (i.e.\ requires we perform the maximal number of swaps for each insertion). In this case, we would be required to swap $\lfloor\log n\rfloor$ times for each of our $n$ insertions.

\begin{lemma}
\label{heaphalf}
At least half of the nodes in a heap are in the last two levels (have depth $d \geq h - 1$)
\end{lemma}

Based on lemma~\ref{heaphalf}, we can ignore all levels above the bottom two when computing the lower bound. The worst case number of swaps at level $h-1$ or $h$ is at least $h-1$, thus the overall number of swaps $s \geq \frac{n}{2} (h-1)$ which is $\Omega(n\log n)$.

We can also creation a heap in the {\bf bottom-up} fashion as such: the entire array is transformed into a heap in one iteration, by finding the elements from largest to smallest and inserting them in that order.

We begin in the same way as for top-down creation, by placing our array into a incomplete binary tree (or associating our already-made array with a binary tree). Now, we start with the element in the last position and perform a top-down swap operation for each element in the array (recursing backwards).

This is very similar to the top-down heap creation method, but has different boundaries.

Since our swaps can now be made in the opposite direction, our lowest level of the tree no longer needs to swap and our second lowest level can only possible swap once. As such, over half of our tree has a maximal swapping runtime of $O(1)$ and the remainder of the tree has $O(\log n)$, whereas the top-down approach uses the constant boundary $O(\log n)$.

More concretely, the total number of swaps we can perform is equal to
\begin{align*}
\sum_{i=0}^h i2^{h-i} < n\sum_{i=0}^\infty \frac{i}{2^i}\\
&< 2n
\end{align*}
and thus we have the upper bound of $O(n)$.

The lower bound is at least $\Omega(n)$ (since we must run our heap creation on $n$ elements), thus we have an overall runtime complexity of $\Theta(n)$.

\subsubsection{Heap Sort}
The heap sort algorithm is
\begin{verbatim}
heapSort(A, n):
    H = new Heap(n)
    for i in range(0, n - 1):
        heapInsert(H, A[i])
    for i in range(0, n - 1):
        A[n-1 - i] = heapDeleteMax(H, n-1)
\end{verbatim}
or given our ``heapify'' algorithm
\begin{verbatim}
heapSort(A, n):
    H = heapify(A, n)
    for i in range(0, n - 1):
        A[n-1 - i] = heapDeleteMax(H, n-1)
\end{verbatim}
which gives us a complexity of
\begin{align*}
O(n) + \sum_{i=0}^{n-1} \Theta(\log n) &= O(n) + \Theta(n\log n)\\
&= \Theta(n\log n)
\end{align*}
% END OTHER LECTURER

\end{document}

