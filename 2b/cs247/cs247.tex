\documentclass[12pt]{article}
\usepackage{amsmath,amssymb,hyperref,parskip,custom}
\usepackage[margin=.8in]{geometry}
\allowdisplaybreaks
\hypersetup{colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\begin{document}

\title{CS 247 --- Software Engineering Principles}
\author{Kevin James}
\date{\vspace{-2ex}Spring 2014}
\maketitle\HRule

\tableofcontents
\newpage

\section{Object-Orientation}
Code which follows {\bf object-oriented} patterns has better affinity between user-defined types and real-world types, can be more easily reused (inheritance, composition, as-is, polymorphism), allows for encapsulation and information hiding, decomposes extremely effectively (and thus seperates concerns), and allows for abstraction through ADTs (Abstract data types), interfaces, etc.

\subsection{ADTs}
An ADT is a user-defined data type. They are composed with a range of legal values and functions that maniplate variables of a given type. By providing compiler support for these type restrictions, we turn programmer errors into type errors (which are checked by the compiler).

One of the main motivations for designing an ADT is to ensure safety of any client code. Other motivations include evolvability and scalability. ADTs also tend to improve code efficiency by limiting range checks to constructors and mutators.

An ADT constructor initializes the new object to some legal value and throws an error if the passed-in value is illegal. Accessors and mutators provide restricted read/write access to one of the values in the object. It is best practice to ensure legality within each mutator and use \code{const} references whenever possible.

We use the {\bf outside-in} method fo development: first we determine what the user wants out of it, then we design and implement it.

{\bf Function Overloading} is syntactic sugar which allows us to define a function with the same name as some other function, so long as this new function has different parameters. It is generally best practice to only overload functions when the purpose of the function is the same for each. For example: \code{void print(int)} and \code{void print{float}}.

Another option is to use {\bf default arguments}. Defualt arguments tend to be used when a given argument should be optional. For example: \code{void print(int, outputStream=cout)}. Default arguments must appear only in the function declaration.

We can also overload operators. For example, we could define the sum of two classes as some other class, some modified version of one class, or even a standard data type of some sort with \code{MyClass operator+(const MyClass\&, const MyClass\&)}. Though widely used, this practice should be used sparingly, if at all.

{\bf Nonmember functions} are critical ADT functions which are declared outside of the class. This leads to ebtter encapsulation and more flexible packaging. Additonally, certain functions are required to be nonmember functions (e.g.\ \code{operator>>}). Streaming operators should be nonmember functions so that they can accept a stream as a first operand and thus chain stream operations.

A class can have \code{private}, \code{protected}, and \code{public} data members and functions (in addition to several less-often used flags). It is best practice to use the most secure flag as possible (generally: \code{private}); though the \code{public} flag is sometimes necessary, the \code{protected} flag should be avoided. We can also use the \code{friend} flag to create a \code{private} method which is accessible to a given other class.

\subsection{Inheritance}
{\bf Inheritance} allows us to create classes ({\bf derived classes}) which include the data members and functions of a {\bf base class}.

\subsection{Polymorphism}
When we create a derived class, that class can inherit pointers from its parent.

{\bf Object slicing} occurs when only base class fields are copied from a subclass. It can occur as a side-effect of intereactions between a subclass and a superclass: passing the sublcass by value, assigning the subclass to the superclass, or suing the superclass assignment operator between subclass instances.

{\bf Function binding} occurs at compile time. When a base class pointer is given a reference to a subclass after its declaration, the subclasses methods will not be called.

{\bf Virtual functions} are a method of getting around this. A virtual function delays function lookup to runtime, and thus will ensure the subclass function will be called even when using a pointer to the base class.

When having an instance of a base class doesn't make sense, we can make a {\bf pure virtual function}. Pure virtual functions need no definitition and prevent class instatiation. They also ensure all subclasses must have a definition for that function.

\subsection{Overloading}
{\bf Overloading} occurs when two functions with the same name have a different set (amount or type) of parameters.

\subsection{Overriding}
{\bf Overriding} occurs in subclasses, when a subclass function has the same signature as a superclass function. When this function is called from the derived class, the derived class' version of the function will be called.

\subsection{Friendship}
The {\bf friend} command allows us to declare a class or function which can access the private members of the class containing the friend declaration.

For example:
\begin{verbatim}
class Base {
    int priv;
public:
    friend void print(Base);
};

void print (Base esab) {
    cout << esab.priv << endl;
}
\end{verbatim}

\subsection{Helper Functions}
The best practice is to hide helper functions as \code{private} methods or within a namespace. Helper functions modularize our code, but should not pollute the gloal namespace.

\section{Entity vs Value Objects}
{\bf Entity Objects} are the digital embodiment of a real-world entity. Each object has a distinct identity and objects with the same attribute values are not equal. {\bf Value Objects} simply represent a value of an ADT.\@ Value objects with the same attribute values are considered to be identical.

An operation on an entity object should reflect a real-world event: copying is not meaningful---though cloning may be, entities referred to by pointers are useless (due to the no-copy rule), and computation on entities are not meaningful (overload \code{new} and \code{delete}, maybe \code{operator<}). Virtual functions and inheritance are uncommon for value-based ADTs, though equality and computations are useful.

\subsection{Singleton Design Pattern}
The {\bf Singleton Design Pattern} ensures that only one object of our ADT exists. By using a structure of the form
\begin{verbatim}
class ADT {
    static ADT a;
    ADT() {}
    ADT(const ADT&);
public:
    static ADT* instance() {
        return &a;
    }
};
\end{verbatim}
we can ensure that the singleton is created the first time, then \emph{referenced} every time thereafter.

\subsection{Essential Methods}
Some C++ member functions are necessary for all object definitions and will thus be inserted by default if no implementation is provided. These include
\begin{itemize}
\item the default constructor (if and only if we do not define any other constructor)
\item the destructor
\item the copy constructor
\item the assignment operator
\end{itemize}
in addition, the equality operator should be defined for all objects, though it has no default implementation.

If we do not declare a copy constructor (a constructor which copies class instances), the default copy constructor will be created based on {\bf memberwise initialization} such that
\begin{itemize}
\item simple data members are bitwise copied
\item pointer members are bitwise copied
\item member objects are copied using their copy constructors
\item inherited members are copied using thir copy constructors
\end{itemize}
The assignment operator follows the same pattern as the above.

The default constructor follows a slightly different set of default values ({\bf memberwise initialization})
\begin{itemize}
\item simple data members are uninitialized
\item pointer members are uninitialized
\item member objects are initialized using their default constructors
\item inherited members are initialized using their default constructors
\end{itemize}

The deconstructor is similar since it uses {\bf memberwise destruction}
\begin{itemize}
\item simple data mambers are deallocated
\item pointer members deallocate the pointer
\item member objects call their destructor
\item inherited members call their destructor
\end{itemize}

\subsection{Mutable vs Immutable Objects}
Entity objects are {\bf mutable}, that is, their objects can change via mutators or other functions. Value objects, though, are often {\bf immutable}: their objects can not change value, a new object must be created instead.

It is possible, though, to design a mutable value-based ADT:\@
\begin{verbatim}
Person myPerson("David", new Date(1, "May", 1990));
cout << myPerson.DOB;

Date myDate = myPerson.DOB;
myDate.monthIs(myDate + 1);
cout << myPerson.DOB;
\end{verbatim}
This is generally a bad design: this ADT has a mutable date field if and only if the constructor did not create a {\bf deep copy} of the input date and the accessor did not return a deep copy. If either of these do not create a copy, the original, mutable object continues to be accessible externally.

\subsubsection{Copy Types}
A deep copy creates an entirely new instance of an object.
\begin{verbatim}
class ADT {
    Date d;
public:
    void setDate(const Date din) {
        d = new Date(din);
    }
}
\end{verbatim}

A {\bf shallow copy} simply creates a pointer to the copied object.
\begin{verbatim}
class ADT {
    Date d;
public:
    void setDate(const Date din) {
        d = din;
    }
}
\end{verbatim}

\section{Polymorphism}
The compiled byte code contains executable code for every function and method definition. The compiler can see at compile time which method should be executed. When we add virtual functions, each class with such a function will have a {\bf vtable} of pointers to these functions and a pointer to its vtable. This allows us to call the same functions from multiple subclasses without reimplementing them.

The general convention as to whether a public function is to be made virtual is made for the class as a whole instead of for each individual function. This is generally based on whether the class should be polymorphic or not.

We can use the assignment operator to assign derived class instances to base class instances.
\begin{verbatim}
int main (void) {
    Base b(42, 'x');
    Derived d(10, 'c', 8.1);
    b = d;
}
\end{verbatim}
This assignment will not copy the derived class' extra data members or vpointers. We call this {\bf object slicing}.

If there exists any virtual function, the class is polymorphic and should thus have a virtual destructor. If we do not implement this manually, the compiler will default to creating a non-virtual constructor.

In order to print a polymorphic function, we generally
\begin{itemize}
\item create a \code{virtual void print(std::ostream\& os) const;} function which does the actual printing
\item create a non-member function \code{std::ostream\& operator<<(std::ostream\& os, const ADT\& adt);} which takes an instance of the class and calls the \code{print()} member function
\end{itemize}

The overloaded streaming operator generally looks similar to
\begin{verbatim}
std::ostream& operator<<(std::ostream& os, const ADT& adt) {
    adt.print(os);
    return os;
}
\end{verbatim}

In general, we have
\begin{verbatim}
class ADT {
public:
    ADT();
    ADT(ADT& adt);
    virtual ~ADT();
    void operator=(ADT& adt);
    virtual bool operator==(ADT& adt);
    virtual void print(std::ostream& os);
}
\end{verbatim}

% HOW TO COMPILE AND LINK

\section{Exceptions}
An {\bf exception} is an unusual event or situtation which prevents a function from completing normally. In C++, we handle exceptions in a separate section from our normal code: risky and risk-free code is separated, different areas of our program can handle exceptions in a different manner, and errors can not be silently ignored.

We handle errors in a block of code with
\begin{verbatim}
try {
    // risky code
} catch(exceptionType1& e) {
    std::cout << "Generated exception 1" << std::endl;
    system.exit(-1);
} catch(exceptionType2& e) {
    std::cout << "Generated exception 2" << std::endl;
    system.exit(-2);
} catch(...) {
    std::cout << "Generated unspecified exception" << std::endl;
    throw;
}
\end{verbatim}

An exception is handled by the ``nearest'' handler whose argument matches its type. A {\bf local exception} is one which is handled in the same routine as it is thrown (e.g.\ through an alternative computatino or return value). Otherwise, the exception is caught by the dynamically nearest matching catch-clause whose try-block encloses the throw. If there is no matching handler, the program aborts.

A function may declare a {\bf throw list} of potential exceptions it can throw. An empty list implies it does not throw errors, a missing list implies it may or may not throw. If a function throws an error not in its throw list (if it has one), that exception is considered \code{unspecified} and will crash the program (unless the \code{unspecified()} function has been overloaded).

In order to fully support blind inheritance and allow libraries to change, it is best practice not to use throw lists.

\section{Resource Acquistion is Initialization (RAII)}
The {\bf RAII} idiom equates resource management with object lifetimes. The resource is allocated in the objects constructor and deallocated in its destructor. The standard function signatures are \code{resourceType* allocate(...)} and \code{void release(resourceType*)}

\subsection{Smart Pointers}
A {\bf smart pointer} is an ADT which simulates a pointer while using RAII to provide automatic deallocation. In C99, the \code{auto\_ptr<type>} object is used for this. In C++11, we have \code{unique\_ptr<type>} for single-owner transferable references and \code{shared\_ptr<type>} for multiple-owner automatic deallocation upon lack of references.

An \code{auto\_ptr} is not a substitute for a standard pointer.
\begin{itemize}
\item the \code{operator=} is different
\item we cannot assign an \code{auto\_ptr} to a non-\code{auto\_ptr}
\item we cannot pass an \code{auto\_ptr} to a function parameter that is not an \code{auto\_ptr}
\item we cannot use \code{auto\_ptr}s in STL containers
\end{itemize}

% GET NOTES FROM LARA

\section{Development Practices}
There are many problem areas in program development: code ownership, testing, managing complex requirements, \dots

\subsection{Waterfall Model}
The waterfall model imitates standard engineering procedures: the requirements are developed, then a design plan is created, development is completed, and finally the system is tested. This model is commonly accepted to be flawed: writing software is not the same as architecting a building.

\subsection{Agile Programming}
There are several methodologies which can be described as agile programming: {\bf scrum}, {\bf extreme}, \dots

\subsubsection{Extreme Programming}
{\bf eXtreme Programming (XP)} is a modern software development process models which allows the programmer to lead the process. The goal is to produce high-quality software by ``keeping programming fun''. Though the name suggest high-risk and haphazard development, the opposite is true.

XP encompasses several business ideas, but the main three are pair programming, {\bf design simplicity}, and {\bf automated testing}.

The basic rule of {\bf pair programming} is ``code is never written or modified unless two people are sitting side-by-side in front of one computer''. Programming becomes a dialogue: only one person types, but both people analye, design, program, and test. Pairing is not a long-term commitment; groups only need to remain together for the duration of a single task.

Design cimplicity ensures that a short-term pairing can be productive. By establishing coding standards and writing test code together, the pair can avoid trivial misunderstandings and reach a common understanding.

Pair programming also fosters collective ownership. Any programmer may change any portion of the code at any given time. System integration takes place as often as possible to identify conflicting changes. A working version always exists.

The basic rule of {\bf design simplicity} is ``build the simplest thing that works''. Simple deigns lead to code that can easily be modified or replaced as requirements evolve. ``Embrace change'' is the motto of XP.

Pair programming forces an immediate ``simplicity check'' as design ideas are explained to the second programmer. Automated testing gives programmers the confidence that design changes have been correctly implemented. An overall system metaphor guides the design process.

A simple design has no duplicated code or logic. {\bf Refactoring} is the process of simplifying code to avoid or eliminate duplication. For example: code may be refactored to combine two similar classes or to extend them from the same base class.

The baseic rule of {\bf automated testing} is ``write the tests first''. Automated tests should become an integral component of the program, which can be allowed to self-test at any time. System integration takes place as often as possible. Automated testing ensures that a working version of the program always exists.

Design simplicity makes it easy to write tests. Each programmer thinks of ways to test their partner's ideas. A successful test provides the gratification which programmers crave.

\end{document}
