\documentclass[12pt]{article}
\usepackage{amsmath,amssymb,parskip,custom}
\usepackage[margin=1in]{geometry}
\begin{document}

\title{CS 247 --- Software Engineering Principles}
\author{Kevin James}
\date{\vspace{-2ex}Spring 2014}
\maketitle\HRule

\section{Object-Orientation}
Code which follows {\bf object-oriented} patterns has better affinity between user-defined types and real-world types, can be more easily reused (inheritance, composition, as-is, polymorphism), allows for encapsulation and information hiding, decomposes extremely effectively (and thus seperates concerns), and allows for abstraction through ADTs (Abstract data types), interfaces, etc.

\subsection{ADTs}
An ADT is a user-defined data type. They are composed with a range of legal values and functions that maniplate variables of a given type. By providing compiler support for these type restrictions, we turn programmer errors into type errors (which are checked by the compiler).

One of the main motivations for designing an ADT is to ensure safety of any client code. Other motivations include evolvability and scalability. ADTs also tend to improve code efficiency by limiting range checks to constructors and mutators.

An ADT constructor initializes the new object to some legal value and throws an error if the passed-in value is illegal. Accessors and mutators provide restricted read/write access to one of the values in the object. It is best practice to ensure legality within each mutator and use \code{const} references whenever possible.

We use the {\bf outside-in} method fo development: first we determine what the user wants out of it, then we design and implement it.

{\bf Function Overloading} is syntactic sugar which allows us to define a function with the same name as some other function, so long as this new function has different parameters. It is generally best practice to only overload functions when the purpose of the function is the same for each. For example: \code{void print(int)} and \code{void print{float}}.

Another option is to use {\bf default arguments}. Defulat arguments tend to be used when a given argument should be optional. For example: \code{void print(int, outputStream=cout)}. Default arguments must appear only in the function declaration.

We can also overload operators. For example, we could define the sum of two classes as some other class, some modified version of one class, or even a standard data type of some sort with \code{MyClass operator+(const MyClass\&, const MyClass\&)}. Though widely used, this practice should be used sparingly, if at all.

{\bf Nonmember functions} are critical ADT functions which are declared outside of the class. This leads to ebtter encapsulation and more flexible packaging. Additonally, certain functions are required to be nonmember functions (e.g.\ \code{operator>>}). Streaming operators should be nonmember functions so that they can accept a stream as a first operand and thus chain stream operations.

A class can have \code{private}, \code{protected}, and \code{public} data members and functions (in addition to several less-often used flags). It is best practice to use the most secure flag as possible (generally: \code{private}). We can also use the \code{friend} flag to create a \code{private} method which is accessible to a given other class.

\subsection{Inheritance}
{\bf Inheritance} allows us to crreate classes ({\bf derived classes}) which include the data members and functions of a {\bf base class}.

\subsection{Polymorphism}
When we create a derived class, that class can inherit pointers from its parent.

{\bf Object slicing} occurs when only base class fields are copied from a subclass. It can occur as a side-effect of intereactions between a subclass and a superclass: passing the sublcass by value, assigning the subclass to the superclass, or suing the superclass assignment operator between subclass instances.

{\bf Function binding} occurs at compile time. When a base class pointer is given a reference to a subclass after its declaration, the subclasses methods will not be called.

{\bf Virtual functions} are a method of getting around this. A virtual function delays function lookup to runtime, and thus will ensure the subclass function will be called even when using a pointer to the base class.

When having an instance of a base class doesn't make sense, we can make a {\bf pure virtual function}. Pure virtual functions need no definitition and prevent class instatiation. They also ensure all subclasses must have a definition for that function.

\subsection{Overloading}
{\bf Overloading} occurs when two functions with the same name have a different set (amount or type) of parameters.

\subsection{Overriding}
{\bf Overriding} occurs in subclasses, when a subclass function has the same signature as a superclass function. When this function is called from the derived class, the derived class' version of the function will be called.

\subsection{Friendship}
The {\bf friend} command allows us to declare a class or function which can access the private members of the class containing the friend declaration.

For example:
\begin{verbatim}
class Base {
    int priv;
public:
    friend void print(Base);
}

void print (Base esab) {
    cout << esab.priv << endl;
}
\end{verbatim}

\end{document}
